#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nğŸ”— Danbooru BGE-M3 RAG Server - é›†æˆç¤ºä¾‹\n=========================================\n\næœ¬æ–‡ä»¶å±•ç¤ºå¦‚ä½•å°†Danbooru BGE-M3 RAGæœåŠ¡å™¨é›†æˆåˆ°å„ç§åº”ç”¨ä¸­ï¼š\n- Stable Diffusion WebUI\n- ComfyUI\n- Discord Bot\n- Webåº”ç”¨\n- APIé›†æˆ\n\"\"\"\n\nimport asyncio\nimport json\nimport requests\nfrom typing import Dict, List, Any\nimport websockets\nimport discord\nfrom discord.ext import commands\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nimport gradio as gr\n\nclass DanbooruRAGIntegration:\n    \"\"\"Danbooru RAGé›†æˆåŸºç¡€ç±»\"\"\"\n    \n    def __init__(self, server_url: str = \"http://localhost:8000\"):\n        self.server_url = server_url\n        self.session = requests.Session()\n    \n    def search_tags(self, query: str, limit: int = 20) -> Dict[str, Any]:\n        \"\"\"æœç´¢æ ‡ç­¾\"\"\"\n        try:\n            response = self.session.post(\n                f\"{self.server_url}/search\",\n                json={\"query\": query, \"limit\": limit}\n            )\n            return response.json()\n        except Exception as e:\n            return {\"error\": str(e), \"results\": []}\n    \n    def analyze_prompts(self, prompts: List[str]) -> Dict[str, Any]:\n        \"\"\"åˆ†ææç¤ºè¯\"\"\"\n        try:\n            response = self.session.post(\n                f\"{self.server_url}/analyze_prompts\",\n                json={\"prompts\": prompts}\n            )\n            return response.json()\n        except Exception as e:\n            return {\"error\": str(e), \"analysis\": {}}\n    \n    def create_scene_prompt(self, description: str, nsfw_level: str = \"none\") -> Dict[str, Any]:\n        \"\"\"ä»åœºæ™¯æè¿°åˆ›å»ºæç¤ºè¯\"\"\"\n        try:\n            response = self.session.post(\n                f\"{self.server_url}/create_prompt_from_scene\",\n                json={\"scene_description\": description, \"nsfw_level\": nsfw_level}\n            )\n            return response.json()\n        except Exception as e:\n            return {\"error\": str(e), \"positive_prompt\": \"\", \"negative_prompt\": \"\"}\n\n# ==============================================================================\n# ğŸ¨ Stable Diffusion WebUI é›†æˆ\n# ==============================================================================\n\nclass StableDiffusionWebUIPlugin:\n    \"\"\"Stable Diffusion WebUIæ’ä»¶\"\"\"\n    \n    def __init__(self, rag_client: DanbooruRAGIntegration):\n        self.rag = rag_client\n        self.webui_api_url = \"http://127.0.0.1:7860\"\n    \n    def enhance_prompt(self, user_prompt: str) -> Dict[str, str]:\n        \"\"\"å¢å¼ºç”¨æˆ·æç¤ºè¯\"\"\"\n        print(f\"ğŸ” åˆ†æç”¨æˆ·æç¤ºè¯: '{user_prompt}'\")\n        \n        # ä½¿ç”¨RAGç³»ç»Ÿåˆ†æå’Œå¢å¼ºæç¤ºè¯\n        result = self.rag.search_tags(user_prompt, limit=10)\n        \n        if \"error\" not in result:\n            # æå–æ¨èæ ‡ç­¾\n            enhanced_tags = []\n            for item in result.get(\"results\", [])[:5]:\n                if \"tag\" in item:\n                    enhanced_tags.append(item[\"tag\"])\n            \n            # æ„å»ºå¢å¼ºæç¤ºè¯\n            enhanced_prompt = user_prompt\n            if enhanced_tags:\n                enhanced_prompt += \", \" + \", \".join(enhanced_tags)\n            \n            # æ·»åŠ è´¨é‡æ ‡ç­¾\n            quality_tags = \"masterpiece, best quality, ultra detailed\"\n            enhanced_prompt = quality_tags + \", \" + enhanced_prompt\n            \n            # è´Ÿé¢æç¤ºè¯\n            negative_prompt = \"worst quality, low quality, normal quality, lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, jpeg artifacts, signature, watermark, username, blurry\"\n            \n            return {\n                \"positive\": enhanced_prompt,\n                \"negative\": negative_prompt,\n                \"original\": user_prompt,\n                \"added_tags\": enhanced_tags\n            }\n        \n        return {\n            \"positive\": user_prompt,\n            \"negative\": \"\",\n            \"original\": user_prompt,\n            \"added_tags\": [],\n            \"error\": result.get(\"error\", \"Unknown error\")\n        }\n    \n    def generate_image_with_rag(self, scene_description: str, width: int = 512, height: int = 512) -> Dict[str, Any]:\n        \"\"\"ä½¿ç”¨RAGç³»ç»Ÿç”Ÿæˆå›¾åƒ\"\"\"\n        print(f\"ğŸ¨ åŸºäºåœºæ™¯æè¿°ç”Ÿæˆå›¾åƒ: '{scene_description}'\")\n        \n        # ä½¿ç”¨RAGç³»ç»Ÿåˆ›å»ºæç¤ºè¯\n        prompt_result = self.rag.create_scene_prompt(scene_description)\n        \n        if \"error\" not in prompt_result:\n            # è°ƒç”¨Stable Diffusion WebUI API\n            webui_payload = {\n                \"prompt\": prompt_result.get(\"positive_prompt\", scene_description),\n                \"negative_prompt\": prompt_result.get(\"negative_prompt\", \"\"),\n                \"width\": width,\n                \"height\": height,\n                \"steps\": 20,\n                \"cfg_scale\": 7,\n                \"sampler_index\": \"DPM++ 2M Karras\"\n            }\n            \n            try:\n                response = requests.post(\n                    f\"{self.webui_api_url}/sdapi/v1/txt2img\",\n                    json=webui_payload\n                )\n                \n                if response.status_code == 200:\n                    result = response.json()\n                    return {\n                        \"success\": True,\n                        \"images\": result.get(\"images\", []),\n                        \"used_prompt\": prompt_result.get(\"positive_prompt\"),\n                        \"used_negative\": prompt_result.get(\"negative_prompt\"),\n                        \"scene_analysis\": prompt_result.get(\"scene_analysis\", {})\n                    }\n                else:\n                    return {\"success\": False, \"error\": f\"WebUI API error: {response.status_code}\"}\n            \n            except Exception as e:\n                return {\"success\": False, \"error\": f\"Connection error: {str(e)}\"}\n        \n        return {\"success\": False, \"error\": prompt_result.get(\"error\", \"Unknown error\")}\n\n# ==============================================================================\n# ğŸ–¼ï¸ ComfyUI é›†æˆ\n# ==============================================================================\n\nclass ComfyUIIntegration:\n    \"\"\"ComfyUIé›†æˆ\"\"\"\n    \n    def __init__(self, rag_client: DanbooruRAGIntegration):\n        self.rag = rag_client\n        self.comfy_url = \"http://127.0.0.1:8188\"\n    \n    def create_workflow_with_rag(self, user_input: str) -> Dict[str, Any]:\n        \"\"\"åˆ›å»ºå¸¦RAGå¢å¼ºçš„ComfyUIå·¥ä½œæµ\"\"\"\n        print(f\"ğŸ”§ ä¸ºComfyUIåˆ›å»ºå¢å¼ºå·¥ä½œæµ: '{user_input}'\")\n        \n        # ä½¿ç”¨RAGåˆ†æè¾“å…¥\n        rag_result = self.rag.create_scene_prompt(user_input)\n        \n        if \"error\" not in rag_result:\n            # åˆ›å»ºComfyUIå·¥ä½œæµJSON\n            workflow = {\n                \"1\": {\n                    \"class_type\": \"CheckpointLoaderSimple\",\n                    \"inputs\": {\"ckpt_name\": \"model.safetensors\"}\n                },\n                \"2\": {\n                    \"class_type\": \"CLIPTextEncode\",\n                    \"inputs\": {\n                        \"text\": rag_result.get(\"positive_prompt\", user_input),\n                        \"clip\": [\"1\", 1]\n                    }\n                },\n                \"3\": {\n                    \"class_type\": \"CLIPTextEncode\",\n                    \"inputs\": {\n                        \"text\": rag_result.get(\"negative_prompt\", \"\"),\n                        \"clip\": [\"1\", 1]\n                    }\n                },\n                \"4\": {\n                    \"class_type\": \"EmptyLatentImage\",\n                    \"inputs\": {\"width\": 512, \"height\": 512, \"batch_size\": 1}\n                },\n                \"5\": {\n                    \"class_type\": \"KSampler\",\n                    \"inputs\": {\n                        \"seed\": 42,\n                        \"steps\": 20,\n                        \"cfg\": 7.0,\n                        \"sampler_name\": \"euler\",\n                        \"scheduler\": \"normal\",\n                        \"denoise\": 1.0,\n                        \"model\": [\"1\", 0],\n                        \"positive\": [\"2\", 0],\n                        \"negative\": [\"3\", 0],\n                        \"latent_image\": [\"4\", 0]\n                    }\n                },\n                \"6\": {\n                    \"class_type\": \"VAEDecode\",\n                    \"inputs\": {\n                        \"samples\": [\"5\", 0],\n                        \"vae\": [\"1\", 2]\n                    }\n                },\n                \"7\": {\n                    \"class_type\": \"SaveImage\",\n                    \"inputs\": {\n                        \"filename_prefix\": \"RAG_Generated\",\n                        \"images\": [\"6\", 0]\n                    }\n                }\n            }\n            \n            return {\n                \"success\": True,\n                \"workflow\": workflow,\n                \"rag_analysis\": rag_result,\n                \"enhanced_prompt\": rag_result.get(\"positive_prompt\")\n            }\n        \n        return {\"success\": False, \"error\": rag_result.get(\"error\")}\n\n# ==============================================================================\n# ğŸ¤– Discord Bot é›†æˆ\n# ==============================================================================\n\nclass DanbooruDiscordBot(commands.Bot):\n    \"\"\"Discord Boté›†æˆ\"\"\"\n    \n    def __init__(self, rag_client: DanbooruRAGIntegration):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        super().__init__(command_prefix='!', intents=intents)\n        \n        self.rag = rag_client\n        \n        # æ·»åŠ å‘½ä»¤\n        self.add_commands()\n    \n    def add_commands(self):\n        @self.command(name='search')\n        async def search_tags(ctx, *, query: str):\n            \"\"\"æœç´¢Danbooruæ ‡ç­¾\"\"\"\n            await ctx.send(f\"ğŸ” æœç´¢æ ‡ç­¾: `{query}`\")\n            \n            result = self.rag.search_tags(query, limit=5)\n            \n            if \"error\" not in result and result.get(\"results\"):\n                embed = discord.Embed(\n                    title=\"ğŸ·ï¸ æœç´¢ç»“æœ\",\n                    description=f\"ä¸ºæŸ¥è¯¢ `{query}` æ‰¾åˆ°ä»¥ä¸‹æ ‡ç­¾:\",\n                    color=0x00ff00\n                )\n                \n                for i, item in enumerate(result[\"results\"][:5], 1):\n                    tag = item.get(\"tag\", \"æœªçŸ¥\")\n                    translation = item.get(\"translation\", \"æ— ç¿»è¯‘\")\n                    confidence = item.get(\"confidence\", 0)\n                    \n                    embed.add_field(\n                        name=f\"{i}. {tag}\",\n                        value=f\"ç¿»è¯‘: {translation}\\nç½®ä¿¡åº¦: {confidence:.2f}\",\n                        inline=False\n                    )\n                \n                await ctx.send(embed=embed)\n            else:\n                await ctx.send(f\"âŒ æœç´¢å¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}\")\n        \n        @self.command(name='generate')\n        async def generate_prompt(ctx, *, description: str):\n            \"\"\"ä»åœºæ™¯æè¿°ç”Ÿæˆæç¤ºè¯\"\"\"\n            await ctx.send(f\"ğŸ¨ ç”Ÿæˆæç¤ºè¯: `{description}`\")\n            \n            result = self.rag.create_scene_prompt(description)\n            \n            if \"error\" not in result:\n                embed = discord.Embed(\n                    title=\"âœ¨ ç”Ÿæˆçš„æç¤ºè¯\",\n                    color=0x0099ff\n                )\n                \n                positive = result.get(\"positive_prompt\", \"\")\n                negative = result.get(\"negative_prompt\", \"\")\n                \n                if len(positive) > 1024:\n                    positive = positive[:1021] + \"...\"\n                if len(negative) > 1024:\n                    negative = negative[:1021] + \"...\"\n                \n                embed.add_field(\n                    name=\"ğŸŸ¢ æ­£é¢æç¤ºè¯\",\n                    value=f\"```{positive}```\",\n                    inline=False\n                )\n                \n                if negative:\n                    embed.add_field(\n                        name=\"ğŸ”´ è´Ÿé¢æç¤ºè¯\",\n                        value=f\"```{negative}```\",\n                        inline=False\n                    )\n                \n                await ctx.send(embed=embed)\n            else:\n                await ctx.send(f\"âŒ ç”Ÿæˆå¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}\")\n        \n        @self.command(name='analyze')\n        async def analyze_prompts(ctx, *, prompts: str):\n            \"\"\"åˆ†ææç¤ºè¯\"\"\"\n            prompt_list = [p.strip() for p in prompts.split(',')]\n            \n            await ctx.send(f\"ğŸ”¬ åˆ†æ {len(prompt_list)} ä¸ªæç¤ºè¯...\")\n            \n            result = self.rag.analyze_prompts(prompt_list)\n            \n            if \"error\" not in result:\n                analysis = result.get(\"analysis\", {})\n                \n                embed = discord.Embed(\n                    title=\"ğŸ“Š æç¤ºè¯åˆ†æç»“æœ\",\n                    color=0xff9900\n                )\n                \n                # æ˜¾ç¤ºåˆ†æç»“æœçš„å…³é”®ä¿¡æ¯\n                nsfw_level = analysis.get(\"nsfw_level\", \"æœªçŸ¥\")\n                complexity = analysis.get(\"complexity_score\", 0)\n                \n                embed.add_field(\n                    name=\"ğŸ” NSFWç­‰çº§\",\n                    value=nsfw_level,\n                    inline=True\n                )\n                \n                embed.add_field(\n                    name=\"ğŸ§© å¤æ‚åº¦\",\n                    value=f\"{complexity:.1%}\",\n                    inline=True\n                )\n                \n                tags_found = len(analysis.get(\"individual_analysis\", []))\n                embed.add_field(\n                    name=\"ğŸ·ï¸ è¯†åˆ«æ ‡ç­¾æ•°\",\n                    value=str(tags_found),\n                    inline=True\n                )\n                \n                await ctx.send(embed=embed)\n            else:\n                await ctx.send(f\"âŒ åˆ†æå¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}\")\n\n# ==============================================================================\n# ğŸŒ Webåº”ç”¨é›†æˆ (FastAPI)\n# ==============================================================================\n\nclass DanbooruWebAPI:\n    \"\"\"Web APIé›†æˆ\"\"\"\n    \n    def __init__(self, rag_client: DanbooruRAGIntegration):\n        self.rag = rag_client\n        self.app = FastAPI(title=\"Danbooru RAG API\", version=\"1.0.0\")\n        \n        # æ·»åŠ CORSä¸­é—´ä»¶\n        self.app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n        \n        self.setup_routes()\n    \n    def setup_routes(self):\n        @self.app.get(\"/\")\n        async def root():\n            return {\"message\": \"Danbooru BGE-M3 RAG API\", \"version\": \"1.0.0\"}\n        \n        @self.app.post(\"/api/search\")\n        async def api_search(request: dict):\n            query = request.get(\"query\", \"\")\n            limit = request.get(\"limit\", 20)\n            \n            if not query:\n                raise HTTPException(status_code=400, detail=\"Query is required\")\n            \n            result = self.rag.search_tags(query, limit)\n            return result\n        \n        @self.app.post(\"/api/generate\")\n        async def api_generate(request: dict):\n            description = request.get(\"description\", \"\")\n            nsfw_level = request.get(\"nsfw_level\", \"none\")\n            \n            if not description:\n                raise HTTPException(status_code=400, detail=\"Description is required\")\n            \n            result = self.rag.create_scene_prompt(description, nsfw_level)\n            return result\n        \n        @self.app.post(\"/api/analyze\")\n        async def api_analyze(request: dict):\n            prompts = request.get(\"prompts\", [])\n            \n            if not prompts:\n                raise HTTPException(status_code=400, detail=\"Prompts are required\")\n            \n            result = self.rag.analyze_prompts(prompts)\n            return result\n\n# ==============================================================================\n# ğŸ¨ Gradioç•Œé¢é›†æˆ\n# ==============================================================================\n\ndef create_gradio_interface(rag_client: DanbooruRAGIntegration):\n    \"\"\"åˆ›å»ºGradio Webç•Œé¢\"\"\"\n    \n    def search_interface(query, limit):\n        \"\"\"æœç´¢ç•Œé¢\"\"\"\n        if not query:\n            return \"è¯·è¾“å…¥æœç´¢æŸ¥è¯¢\", \"\"\n        \n        result = rag_client.search_tags(query, int(limit))\n        \n        if \"error\" in result:\n            return f\"é”™è¯¯: {result['error']}\", \"\"\n        \n        # æ ¼å¼åŒ–ç»“æœ\n        output = f\"ğŸ” æœç´¢æŸ¥è¯¢: {query}\\n\\n\"\n        output += f\"ğŸ“Š æ‰¾åˆ° {len(result.get('results', []))} ä¸ªç»“æœ:\\n\\n\"\n        \n        for i, item in enumerate(result.get(\"results\", []), 1):\n            tag = item.get(\"tag\", \"æœªçŸ¥\")\n            translation = item.get(\"translation\", \"æ— ç¿»è¯‘\")\n            confidence = item.get(\"confidence\", 0)\n            \n            output += f\"{i}. **{tag}**\\n\"\n            output += f\"   ç¿»è¯‘: {translation}\\n\"\n            output += f\"   ç½®ä¿¡åº¦: {confidence:.2f}\\n\\n\"\n        \n        # ç”Ÿæˆå¯å¤åˆ¶çš„æ ‡ç­¾åˆ—è¡¨\n        tag_list = \", \".join([item.get(\"tag\", \"\") for item in result.get(\"results\", [])[:10]])\n        \n        return output, tag_list\n    \n    def generate_interface(description, nsfw_level):\n        \"\"\"ç”Ÿæˆç•Œé¢\"\"\"\n        if not description:\n            return \"è¯·è¾“å…¥åœºæ™¯æè¿°\", \"\", \"\"\n        \n        result = rag_client.create_scene_prompt(description, nsfw_level)\n        \n        if \"error\" in result:\n            return f\"é”™è¯¯: {result['error']}\", \"\", \"\"\n        \n        analysis = f\"ğŸ¬ åœºæ™¯åˆ†æ: {description}\\n\\n\"\n        analysis += f\"ğŸ” NSFWç­‰çº§: {nsfw_level}\\n\\n\"\n        \n        scene_analysis = result.get(\"scene_analysis\", {})\n        if scene_analysis:\n            analysis += \"ğŸ“‹ åœºæ™¯è¦ç´ :\\n\"\n            for key, value in scene_analysis.items():\n                analysis += f\"  â€¢ {key}: {value}\\n\"\n        \n        positive = result.get(\"positive_prompt\", \"\")\n        negative = result.get(\"negative_prompt\", \"\")\n        \n        return analysis, positive, negative\n    \n    # åˆ›å»ºGradioç•Œé¢\n    with gr.Blocks(title=\"Danbooru BGE-M3 RAG System\") as demo:\n        gr.Markdown(\"# ğŸ¨ Danbooru BGE-M3 RAG System\")\n        \n        with gr.Tab(\"ğŸ” æ ‡ç­¾æœç´¢\"):\n            with gr.Row():\n                search_input = gr.Textbox(\n                    label=\"æœç´¢æŸ¥è¯¢\", \n                    placeholder=\"è¾“å…¥æ‚¨æƒ³æœç´¢çš„å†…å®¹ï¼Œå¦‚ï¼š1girl blonde_hair\"\n                )\n                search_limit = gr.Slider(\n                    minimum=1, maximum=50, value=10, step=1,\n                    label=\"ç»“æœæ•°é‡\"\n                )\n            \n            search_btn = gr.Button(\"ğŸ” æœç´¢\", variant=\"primary\")\n            \n            with gr.Row():\n                search_output = gr.Textbox(\n                    label=\"æœç´¢ç»“æœ\", \n                    lines=10, \n                    interactive=False\n                )\n                tag_list_output = gr.Textbox(\n                    label=\"æ ‡ç­¾åˆ—è¡¨ (å¯å¤åˆ¶)\", \n                    lines=3, \n                    interactive=True\n                )\n            \n            search_btn.click(\n                search_interface,\n                inputs=[search_input, search_limit],\n                outputs=[search_output, tag_list_output]\n            )\n        \n        with gr.Tab(\"ğŸ¨ åœºæ™¯ç”Ÿæˆ\"):\n            with gr.Row():\n                scene_input = gr.Textbox(\n                    label=\"åœºæ™¯æè¿°\", \n                    placeholder=\"æè¿°æ‚¨æƒ³è¦çš„åœºæ™¯ï¼Œå¦‚ï¼šä¸€ä¸ªå¥³å­©åœ¨æµ·è¾¹çœ‹æ—¥è½\",\n                    lines=3\n                )\n                nsfw_select = gr.Dropdown(\n                    choices=[\"none\", \"low\", \"medium\", \"high\"],\n                    value=\"none\",\n                    label=\"NSFWç­‰çº§\"\n                )\n            \n            generate_btn = gr.Button(\"ğŸ¨ ç”Ÿæˆæç¤ºè¯\", variant=\"primary\")\n            \n            with gr.Row():\n                analysis_output = gr.Textbox(\n                    label=\"åœºæ™¯åˆ†æ\", \n                    lines=8, \n                    interactive=False\n                )\n            \n            with gr.Row():\n                positive_output = gr.Textbox(\n                    label=\"æ­£é¢æç¤ºè¯\", \n                    lines=5, \n                    interactive=True\n                )\n                negative_output = gr.Textbox(\n                    label=\"è´Ÿé¢æç¤ºè¯\", \n                    lines=5, \n                    interactive=True\n                )\n            \n            generate_btn.click(\n                generate_interface,\n                inputs=[scene_input, nsfw_select],\n                outputs=[analysis_output, positive_output, negative_output]\n            )\n    \n    return demo\n\n# ==============================================================================\n# ğŸš€ ä¸»å‡½æ•°å’Œä½¿ç”¨ç¤ºä¾‹\n# ==============================================================================\n\nasync def main():\n    \"\"\"ä¸»å‡½æ•° - æ¼”ç¤ºæ‰€æœ‰é›†æˆ\"\"\"\n    print(\"ğŸ”— Danbooru BGE-M3 RAG Server - é›†æˆç¤ºä¾‹\")\n    print(\"=\" * 50)\n    \n    # åˆå§‹åŒ–RAGå®¢æˆ·ç«¯\n    rag_client = DanbooruRAGIntegration()\n    \n    print(\"\\n1. ğŸ¨ Stable Diffusion WebUI é›†æˆç¤ºä¾‹\")\n    sd_plugin = StableDiffusionWebUIPlugin(rag_client)\n    enhanced = sd_plugin.enhance_prompt(\"cute girl with blue hair\")\n    print(f\"   åŸå§‹: {enhanced['original']}\")\n    print(f\"   å¢å¼º: {enhanced['positive'][:100]}...\")\n    \n    print(\"\\n2. ğŸ–¼ï¸ ComfyUI é›†æˆç¤ºä¾‹\")\n    comfy = ComfyUIIntegration(rag_client)\n    workflow = comfy.create_workflow_with_rag(\"magical girl in forest\")\n    print(f\"   å·¥ä½œæµåˆ›å»º: {'æˆåŠŸ' if workflow['success'] else 'å¤±è´¥'}\")\n    \n    print(\"\\n3. ğŸŒ Web API é›†æˆ\")\n    web_api = DanbooruWebAPI(rag_client)\n    print(\"   FastAPIæœåŠ¡å™¨å·²é…ç½®\")\n    \n    print(\"\\n4. ğŸ¨ Gradioç•Œé¢\")\n    gradio_demo = create_gradio_interface(rag_client)\n    print(\"   Gradioç•Œé¢å·²åˆ›å»º\")\n    \n    print(\"\\n\" + \"=\" * 50)\n    print(\"ğŸ‰ æ‰€æœ‰é›†æˆç¤ºä¾‹é…ç½®å®Œæˆ!\")\n    print(\"ğŸ“– è¯·æŸ¥çœ‹å„ä¸ªç±»çš„è¯¦ç»†å®ç°\")\n    print(\"ğŸ”— æ›´å¤šä¿¡æ¯: https://github.com/2799662352/rag-mcp\")\n    print(\"=\" * 50)\n\nif __name__ == \"__main__\":\n    # è¿è¡Œç¤ºä¾‹\n    asyncio.run(main())